import {
  ConvexCredentials
} from "./chunk-SIDCFT2C.js";
import {
  createAccount,
  invalidateSessions,
  modifyAccountCredentials,
  retrieveAccount,
  signInViaProvider
} from "./chunk-D5SYBGAS.js";
import "./chunk-6GIMFAUN.js";
import "./chunk-E7JIGTN5.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@oslojs/encoding/dist/hex.js
function encodeHexLowerCase(data) {
  let result = "";
  for (let i = 0; i < data.length; i++) {
    result += alphabetLowerCase[data[i] >> 4];
    result += alphabetLowerCase[data[i] & 15];
  }
  return result;
}
function decodeHex(data) {
  if (data.length % 2 !== 0) {
    throw new Error("Invalid hex string");
  }
  const result = new Uint8Array(data.length / 2);
  for (let i = 0; i < data.length; i += 2) {
    if (!(data[i] in decodeMap)) {
      throw new Error("Invalid character");
    }
    if (!(data[i + 1] in decodeMap)) {
      throw new Error("Invalid character");
    }
    result[i / 2] |= decodeMap[data[i]] << 4;
    result[i / 2] |= decodeMap[data[i + 1]];
  }
  return result;
}
var alphabetLowerCase = "0123456789abcdef";
var decodeMap = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

// node_modules/@oslojs/encoding/dist/base32.js
var EncodingPadding;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding || (EncodingPadding = {}));
var DecodingPadding;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding || (DecodingPadding = {}));

// node_modules/@oslojs/encoding/dist/base64.js
var EncodingPadding2;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding2 || (EncodingPadding2 = {}));
var DecodingPadding2;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding2 || (DecodingPadding2 = {}));

// node_modules/@oslojs/binary/dist/uint.js
var BigEndian = class {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] << 8 | data[offset + 1];
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i = 0; i < 4; i++) {
      result |= data[offset + i] << 24 - i * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i = 0; i < 8; i++) {
      result |= BigInt(data[offset + i]) << BigInt(56 - i * 8);
    }
    return result;
  }
  putUint8(target, value, offset) {
    if (target.length < offset + 1) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value;
  }
  putUint16(target, value, offset) {
    if (target.length < offset + 2) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset] = value >> 8;
    target[offset + 1] = value & 255;
  }
  putUint32(target, value, offset) {
    if (target.length < offset + 4) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i = 0; i < 4; i++) {
      target[offset + i] = value >> (3 - i) * 8 & 255;
    }
  }
  putUint64(target, value, offset) {
    if (target.length < offset + 8) {
      throw new TypeError("Not enough space");
    }
    if (value < 0 || value > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i = 0; i < 8; i++) {
      target[offset + i] = Number(value >> BigInt((7 - i) * 8) & 0xffn);
    }
  }
};
var LittleEndian = class {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] | data[offset + 1] << 8;
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i = 0; i < 4; i++) {
      result |= data[offset + i] << i * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i = 0; i < 8; i++) {
      result |= BigInt(data[offset + i]) << BigInt(i * 8);
    }
    return result;
  }
  putUint8(target, value, offset) {
    if (target.length < 1 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value;
  }
  putUint16(target, value, offset) {
    if (target.length < 2 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset + 1] = value >> 8;
    target[offset] = value & 255;
  }
  putUint32(target, value, offset) {
    if (target.length < 4 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i = 0; i < 4; i++) {
      target[offset + i] = value >> i * 8 & 255;
    }
  }
  putUint64(target, value, offset) {
    if (target.length < 8 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value < 0 || value > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i = 0; i < 8; i++) {
      target[offset + i] = Number(value >> BigInt(i * 8) & 0xffn);
    }
  }
};
var bigEndian = new BigEndian();
var littleEndian = new LittleEndian();

// node_modules/@oslojs/crypto/dist/subtle/index.js
function constantTimeEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  let c = 0;
  for (let i = 0; i < a.length; i++) {
    c |= a[i] ^ b[i];
  }
  return c === 0;
}

// node_modules/lucia/dist/scrypt/index.js
async function scrypt(password, salt, options) {
  const { N, r, p } = options;
  const dkLen = options.dkLen ?? 32;
  const maxmem = 1024 ** 3 + 1024;
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = await pbkdf2(password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0; i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      await new Promise((r2) => r2());
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    for (let i = 0; i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++) {
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      }
      BlockMix(tmp, 0, B32, Pi, r);
      await new Promise((r2) => r2());
    }
  }
  const res = await pbkdf2(password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  const y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  const y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  const y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  const y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  const y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  const y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  const y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  const y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
async function pbkdf2(password, salt, options) {
  const pwKey = await crypto.subtle.importKey("raw", password, "PBKDF2", false, ["deriveBits"]);
  const keyBuffer = await crypto.subtle.deriveBits({
    name: "PBKDF2",
    hash: "SHA-256",
    salt,
    iterations: options.c
  }, pwKey, options.dkLen * 8);
  return new Uint8Array(keyBuffer);
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}

// node_modules/lucia/dist/crypto.js
async function generateScryptKey(data, salt, blockSize = 16) {
  const encodedData = new TextEncoder().encode(data);
  const encodedSalt = new TextEncoder().encode(salt);
  const keyUint8Array = await scrypt(encodedData, encodedSalt, {
    N: 16384,
    r: blockSize,
    p: 1,
    dkLen: 64
  });
  return new Uint8Array(keyUint8Array);
}
var Scrypt = class {
  async hash(password) {
    const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));
    const key = await generateScryptKey(password.normalize("NFKC"), salt);
    return `${salt}:${encodeHexLowerCase(key)}`;
  }
  async verify(hash, password) {
    const parts = hash.split(":");
    if (parts.length !== 2)
      return false;
    const [salt, key] = parts;
    const targetKey = await generateScryptKey(password.normalize("NFKC"), salt);
    return constantTimeEqual(targetKey, decodeHex(key));
  }
};

// node_modules/@convex-dev/auth/dist/providers/Password.js
function Password(config = {}) {
  const provider = config.id ?? "password";
  return ConvexCredentials({
    id: "password",
    authorize: async (params, ctx) => {
      var _a;
      const flow = params.flow;
      const passwordToValidate = flow === "signUp" ? params.password : flow === "reset-verification" ? params.newPassword : null;
      if (passwordToValidate !== null) {
        if (config.validatePasswordRequirements !== void 0) {
          config.validatePasswordRequirements(passwordToValidate);
        } else {
          validateDefaultPasswordRequirements(passwordToValidate);
        }
      }
      const profile = ((_a = config.profile) == null ? void 0 : _a.call(config, params, ctx)) ?? defaultProfile(params);
      const { email } = profile;
      const secret = params.password;
      let account;
      let user;
      if (flow === "signUp") {
        if (secret === void 0) {
          throw new Error("Missing `password` param for `signUp` flow");
        }
        const created = await createAccount(ctx, {
          provider,
          account: { id: email, secret },
          profile,
          shouldLinkViaEmail: config.verify !== void 0,
          shouldLinkViaPhone: false
        });
        ({ account, user } = created);
      } else if (flow === "signIn") {
        if (secret === void 0) {
          throw new Error("Missing `password` param for `signIn` flow");
        }
        const retrieved = await retrieveAccount(ctx, {
          provider,
          account: { id: email, secret }
        });
        if (retrieved === null) {
          throw new Error("Invalid credentials");
        }
        ({ account, user } = retrieved);
      } else if (flow === "reset") {
        if (!config.reset) {
          throw new Error(`Password reset is not enabled for ${provider}`);
        }
        const { account: account2 } = await retrieveAccount(ctx, {
          provider,
          account: { id: email }
        });
        return await signInViaProvider(ctx, config.reset, {
          accountId: account2._id,
          params
        });
      } else if (flow === "reset-verification") {
        if (!config.reset) {
          throw new Error(`Password reset is not enabled for ${provider}`);
        }
        if (params.newPassword === void 0) {
          throw new Error("Missing `newPassword` param for `reset-verification` flow");
        }
        const result = await signInViaProvider(ctx, config.reset, { params });
        if (result === null) {
          throw new Error("Invalid code");
        }
        const { userId, sessionId } = result;
        const secret2 = params.newPassword;
        await modifyAccountCredentials(ctx, {
          provider,
          account: { id: email, secret: secret2 }
        });
        await invalidateSessions(ctx, { userId, except: [sessionId] });
        return { userId, sessionId };
      } else if (flow === "email-verification") {
        if (!config.verify) {
          throw new Error(`Email verification is not enabled for ${provider}`);
        }
        const { account: account2 } = await retrieveAccount(ctx, {
          provider,
          account: { id: email }
        });
        return await signInViaProvider(ctx, config.verify, {
          accountId: account2._id,
          params
        });
      } else {
        throw new Error('Missing `flow` param, it must be one of "signUp", "signIn", "reset", "reset-verification" or "email-verification"!');
      }
      if (config.verify && !account.emailVerified) {
        return await signInViaProvider(ctx, config.verify, {
          accountId: account._id,
          params
        });
      }
      return { userId: user._id };
    },
    crypto: {
      async hashSecret(password) {
        return await new Scrypt().hash(password);
      },
      async verifySecret(password, hash) {
        return await new Scrypt().verify(hash, password);
      }
    },
    extraProviders: [config.reset, config.verify],
    ...config
  });
}
function validateDefaultPasswordRequirements(password) {
  if (!password || password.length < 8) {
    throw new Error("Invalid password");
  }
}
function defaultProfile(params) {
  return {
    email: params.email
  };
}
export {
  Password
};
//# sourceMappingURL=@convex-dev_auth_providers_Password.js.map
