{
  "version": 3,
  "sources": ["../../@oslojs/encoding/dist/hex.js", "../../@oslojs/encoding/dist/base32.js", "../../@oslojs/encoding/dist/base64.js", "../../@oslojs/binary/dist/uint.js", "../../@oslojs/crypto/dist/subtle/index.js", "../../lucia/dist/scrypt/index.js", "../../lucia/dist/crypto.js", "../../@convex-dev/auth/src/providers/Password.ts"],
  "sourcesContent": ["export function encodeHexUpperCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetUpperCase[data[i] >> 4];\n        result += alphabetUpperCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function encodeHexLowerCase(data) {\n    let result = \"\";\n    for (let i = 0; i < data.length; i++) {\n        result += alphabetLowerCase[data[i] >> 4];\n        result += alphabetLowerCase[data[i] & 0x0f];\n    }\n    return result;\n}\nexport function decodeHex(data) {\n    if (data.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string\");\n    }\n    const result = new Uint8Array(data.length / 2);\n    for (let i = 0; i < data.length; i += 2) {\n        if (!(data[i] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        if (!(data[i + 1] in decodeMap)) {\n            throw new Error(\"Invalid character\");\n        }\n        result[i / 2] |= decodeMap[data[i]] << 4;\n        result[i / 2] |= decodeMap[data[i + 1]];\n    }\n    return result;\n}\nconst alphabetUpperCase = \"0123456789ABCDEF\";\nconst alphabetLowerCase = \"0123456789abcdef\";\nconst decodeMap = {\n    \"0\": 0,\n    \"1\": 1,\n    \"2\": 2,\n    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n    \"8\": 8,\n    \"9\": 9,\n    a: 10,\n    A: 10,\n    b: 11,\n    B: 11,\n    c: 12,\n    C: 12,\n    d: 13,\n    D: 13,\n    e: 14,\n    E: 14,\n    f: 15,\n    F: 15\n};\n", "export function encodeBase32UpperCase(bytes) {\n    return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase32UpperCaseNoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.None);\n}\nexport function encodeBase32LowerCase(bytes) {\n    return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase32LowerCaseNoPadding(bytes) {\n    return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.None);\n}\n/** Replaced: Use encodeBase32UpperCase() instead. */\nexport function encodeBase32(bytes) {\n    return encodeBase32UpperCase(bytes);\n}\n/** Replaced: Use encodeBase32UpperCaseNoPadding() instead. */\nexport function encodeBase32NoPadding(bytes) {\n    return encodeBase32UpperCaseNoPadding(bytes);\n}\nfunction encodeBase32_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 5) {\n        let buffer = 0n;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 5 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8n) | BigInt(bytes[i + j]);\n            bufferBitSize += 8;\n        }\n        if (bufferBitSize % 5 !== 0) {\n            buffer = buffer << BigInt(5 - (bufferBitSize % 5));\n            bufferBitSize += 5 - (bufferBitSize % 5);\n        }\n        for (let j = 0; j < 8; j++) {\n            if (bufferBitSize >= 5) {\n                result += alphabet[Number((buffer >> BigInt(bufferBitSize - 5)) & 0x1fn)];\n                bufferBitSize -= 5;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[Number((buffer << BigInt(6 - bufferBitSize)) & 0x3fn)];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nexport function decodeBase32(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase32IgnorePadding(encoded) {\n    return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase32_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 8) * 5);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 8) {\n        let chunk = 0n;\n        let bitsRead = 0;\n        for (let j = 0; j < 8; j++) {\n            if (padding === DecodingPadding.Required) {\n                if (encoded[i + j] === \"=\") {\n                    continue;\n                }\n                if (i + j >= encoded.length) {\n                    throw new Error(\"Invalid padding\");\n                }\n            }\n            if (padding === DecodingPadding.Ignore) {\n                if (i + j >= encoded.length || encoded[i + j] === \"=\") {\n                    continue;\n                }\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= BigInt(decodeMap[encoded[i + j]]) << BigInt((7 - j) * 5);\n            bitsRead += 5;\n        }\n        if (bitsRead < 40) {\n            let unused;\n            if (bitsRead === 10) {\n                unused = chunk & 0xffffffffn;\n            }\n            else if (bitsRead === 20) {\n                unused = chunk & 0xffffffn;\n            }\n            else if (bitsRead === 25) {\n                unused = chunk & 0xffffn;\n            }\n            else if (bitsRead === 35) {\n                unused = chunk & 0xffn;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0n) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = Number((chunk >> BigInt(32 - i * 8)) & 0xffn);\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nconst base32UpperCaseAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\nconst base32LowerCaseAlphabet = \"abcdefghijklmnopqrstuvwxyz234567\";\nconst base32DecodeMap = {\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 0,\n    b: 1,\n    c: 2,\n    d: 3,\n    e: 4,\n    f: 5,\n    g: 6,\n    h: 7,\n    i: 8,\n    j: 9,\n    k: 10,\n    l: 11,\n    m: 12,\n    n: 13,\n    o: 14,\n    p: 15,\n    q: 16,\n    r: 17,\n    s: 18,\n    t: 19,\n    u: 20,\n    v: 21,\n    w: 22,\n    x: 23,\n    y: 24,\n    z: 25,\n    \"2\": 26,\n    \"3\": 27,\n    \"4\": 28,\n    \"5\": 29,\n    \"6\": 30,\n    \"7\": 31\n};\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\n", "export function encodeBase64(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.Include);\n}\nexport function encodeBase64NoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.None);\n}\nexport function encodeBase64url(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.Include);\n}\nexport function encodeBase64urlNoPadding(bytes) {\n    return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding.None);\n}\nfunction encodeBase64_internal(bytes, alphabet, padding) {\n    let result = \"\";\n    for (let i = 0; i < bytes.byteLength; i += 3) {\n        let buffer = 0;\n        let bufferBitSize = 0;\n        for (let j = 0; j < 3 && i + j < bytes.byteLength; j++) {\n            buffer = (buffer << 8) | bytes[i + j];\n            bufferBitSize += 8;\n        }\n        for (let j = 0; j < 4; j++) {\n            if (bufferBitSize >= 6) {\n                result += alphabet[(buffer >> (bufferBitSize - 6)) & 0x3f];\n                bufferBitSize -= 6;\n            }\n            else if (bufferBitSize > 0) {\n                result += alphabet[(buffer << (6 - bufferBitSize)) & 0x3f];\n                bufferBitSize = 0;\n            }\n            else if (padding === EncodingPadding.Include) {\n                result += \"=\";\n            }\n        }\n    }\n    return result;\n}\nconst base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst base64urlAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nexport function decodeBase64(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64IgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Ignore);\n}\nexport function decodeBase64url(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Required);\n}\nexport function decodeBase64urlIgnorePadding(encoded) {\n    return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding.Ignore);\n}\nfunction decodeBase64_internal(encoded, decodeMap, padding) {\n    const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);\n    let totalBytes = 0;\n    for (let i = 0; i < encoded.length; i += 4) {\n        let chunk = 0;\n        let bitsRead = 0;\n        for (let j = 0; j < 4; j++) {\n            if (padding === DecodingPadding.Required && encoded[i + j] === \"=\") {\n                continue;\n            }\n            if (padding === DecodingPadding.Ignore &&\n                (i + j >= encoded.length || encoded[i + j] === \"=\")) {\n                continue;\n            }\n            if (j > 0 && encoded[i + j - 1] === \"=\") {\n                throw new Error(\"Invalid padding\");\n            }\n            if (!(encoded[i + j] in decodeMap)) {\n                throw new Error(\"Invalid character\");\n            }\n            chunk |= decodeMap[encoded[i + j]] << ((3 - j) * 6);\n            bitsRead += 6;\n        }\n        if (bitsRead < 24) {\n            let unused;\n            if (bitsRead === 12) {\n                unused = chunk & 0xffff;\n            }\n            else if (bitsRead === 18) {\n                unused = chunk & 0xff;\n            }\n            else {\n                throw new Error(\"Invalid padding\");\n            }\n            if (unused !== 0) {\n                throw new Error(\"Invalid padding\");\n            }\n        }\n        const byteLength = Math.floor(bitsRead / 8);\n        for (let i = 0; i < byteLength; i++) {\n            result[totalBytes] = (chunk >> (16 - i * 8)) & 0xff;\n            totalBytes++;\n        }\n    }\n    return result.slice(0, totalBytes);\n}\nvar EncodingPadding;\n(function (EncodingPadding) {\n    EncodingPadding[EncodingPadding[\"Include\"] = 0] = \"Include\";\n    EncodingPadding[EncodingPadding[\"None\"] = 1] = \"None\";\n})(EncodingPadding || (EncodingPadding = {}));\nvar DecodingPadding;\n(function (DecodingPadding) {\n    DecodingPadding[DecodingPadding[\"Required\"] = 0] = \"Required\";\n    DecodingPadding[DecodingPadding[\"Ignore\"] = 1] = \"Ignore\";\n})(DecodingPadding || (DecodingPadding = {}));\nconst base64DecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"+\": 62,\n    \"/\": 63\n};\nconst base64urlDecodeMap = {\n    \"0\": 52,\n    \"1\": 53,\n    \"2\": 54,\n    \"3\": 55,\n    \"4\": 56,\n    \"5\": 57,\n    \"6\": 58,\n    \"7\": 59,\n    \"8\": 60,\n    \"9\": 61,\n    A: 0,\n    B: 1,\n    C: 2,\n    D: 3,\n    E: 4,\n    F: 5,\n    G: 6,\n    H: 7,\n    I: 8,\n    J: 9,\n    K: 10,\n    L: 11,\n    M: 12,\n    N: 13,\n    O: 14,\n    P: 15,\n    Q: 16,\n    R: 17,\n    S: 18,\n    T: 19,\n    U: 20,\n    V: 21,\n    W: 22,\n    X: 23,\n    Y: 24,\n    Z: 25,\n    a: 26,\n    b: 27,\n    c: 28,\n    d: 29,\n    e: 30,\n    f: 31,\n    g: 32,\n    h: 33,\n    i: 34,\n    j: 35,\n    k: 36,\n    l: 37,\n    m: 38,\n    n: 39,\n    o: 40,\n    p: 41,\n    q: 42,\n    r: 43,\n    s: 44,\n    t: 45,\n    u: 46,\n    v: 47,\n    w: 48,\n    x: 49,\n    y: 50,\n    z: 51,\n    \"-\": 62,\n    _: 63\n};\n", "class BigEndian {\n    uint8(data, offset) {\n        if (data.byteLength < offset + 1) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset];\n    }\n    uint16(data, offset) {\n        if (data.byteLength < offset + 2) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return (data[offset] << 8) | data[offset + 1];\n    }\n    uint32(data, offset) {\n        if (data.byteLength < offset + 4) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result |= data[offset + i] << (24 - i * 8);\n        }\n        return result;\n    }\n    uint64(data, offset) {\n        if (data.byteLength < offset + 8) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0n;\n        for (let i = 0; i < 8; i++) {\n            result |= BigInt(data[offset + i]) << BigInt(56 - i * 8);\n        }\n        return result;\n    }\n    putUint8(target, value, offset) {\n        if (target.length < offset + 1) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 255) {\n            throw new TypeError(\"Invalid uint8 value\");\n        }\n        target[offset] = value;\n    }\n    putUint16(target, value, offset) {\n        if (target.length < offset + 2) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 65535) {\n            throw new TypeError(\"Invalid uint16 value\");\n        }\n        target[offset] = value >> 8;\n        target[offset + 1] = value & 0xff;\n    }\n    putUint32(target, value, offset) {\n        if (target.length < offset + 4) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 4294967295) {\n            throw new TypeError(\"Invalid uint32 value\");\n        }\n        for (let i = 0; i < 4; i++) {\n            target[offset + i] = (value >> ((3 - i) * 8)) & 0xff;\n        }\n    }\n    putUint64(target, value, offset) {\n        if (target.length < offset + 8) {\n            throw new TypeError(\"Not enough space\");\n        }\n        if (value < 0 || value > 18446744073709551615n) {\n            throw new TypeError(\"Invalid uint64 value\");\n        }\n        for (let i = 0; i < 8; i++) {\n            target[offset + i] = Number((value >> BigInt((7 - i) * 8)) & 0xffn);\n        }\n    }\n}\nclass LittleEndian {\n    uint8(data, offset) {\n        if (data.byteLength < offset + 1) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset];\n    }\n    uint16(data, offset) {\n        if (data.byteLength < offset + 2) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        return data[offset] | (data[offset + 1] << 8);\n    }\n    uint32(data, offset) {\n        if (data.byteLength < offset + 4) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result |= data[offset + i] << (i * 8);\n        }\n        return result;\n    }\n    uint64(data, offset) {\n        if (data.byteLength < offset + 8) {\n            throw new TypeError(\"Insufficient bytes\");\n        }\n        let result = 0n;\n        for (let i = 0; i < 8; i++) {\n            result |= BigInt(data[offset + i]) << BigInt(i * 8);\n        }\n        return result;\n    }\n    putUint8(target, value, offset) {\n        if (target.length < 1 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 255) {\n            throw new TypeError(\"Invalid uint8 value\");\n        }\n        target[offset] = value;\n    }\n    putUint16(target, value, offset) {\n        if (target.length < 2 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 65535) {\n            throw new TypeError(\"Invalid uint16 value\");\n        }\n        target[offset + 1] = value >> 8;\n        target[offset] = value & 0xff;\n    }\n    putUint32(target, value, offset) {\n        if (target.length < 4 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 4294967295) {\n            throw new TypeError(\"Invalid uint32 value\");\n        }\n        for (let i = 0; i < 4; i++) {\n            target[offset + i] = (value >> (i * 8)) & 0xff;\n        }\n    }\n    putUint64(target, value, offset) {\n        if (target.length < 8 + offset) {\n            throw new TypeError(\"Insufficient space\");\n        }\n        if (value < 0 || value > 18446744073709551615n) {\n            throw new TypeError(\"Invalid uint64 value\");\n        }\n        for (let i = 0; i < 8; i++) {\n            target[offset + i] = Number((value >> BigInt(i * 8)) & 0xffn);\n        }\n    }\n}\nexport const bigEndian = new BigEndian();\nexport const littleEndian = new LittleEndian();\n", "export function constantTimeEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let c = 0;\n    for (let i = 0; i < a.length; i++) {\n        c |= a[i] ^ b[i];\n    }\n    return c === 0;\n}\n", "/*\nThe MIT License (MIT)\n\nCopyright (c) 2022 Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\nexport async function scrypt(password, salt, options) {\n    const { N, r, p } = options;\n    const dkLen = options.dkLen ?? 32;\n    const maxmem = 1024 ** 3 + 1024;\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");\n    }\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n        throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    const B = await pbkdf2(password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = u32(B);\n    const V = u32(new Uint8Array(blockSize * N));\n    const tmp = u32(new Uint8Array(blockSize));\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            await new Promise((r) => r()); // await next tick\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++) {\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            }\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            await new Promise((r) => r()); // await next tick\n        }\n    }\n    const res = await pbkdf2(password, B, { c: 1, dkLen });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\nfunction rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    const y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    const y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    const y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    const y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    const y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    const y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    const y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    const y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= rotl((x00 + x12) | 0, 7);\n        x08 ^= rotl((x04 + x00) | 0, 9);\n        x12 ^= rotl((x08 + x04) | 0, 13);\n        x00 ^= rotl((x12 + x08) | 0, 18);\n        x09 ^= rotl((x05 + x01) | 0, 7);\n        x13 ^= rotl((x09 + x05) | 0, 9);\n        x01 ^= rotl((x13 + x09) | 0, 13);\n        x05 ^= rotl((x01 + x13) | 0, 18);\n        x14 ^= rotl((x10 + x06) | 0, 7);\n        x02 ^= rotl((x14 + x10) | 0, 9);\n        x06 ^= rotl((x02 + x14) | 0, 13);\n        x10 ^= rotl((x06 + x02) | 0, 18);\n        x03 ^= rotl((x15 + x11) | 0, 7);\n        x07 ^= rotl((x03 + x15) | 0, 9);\n        x11 ^= rotl((x07 + x03) | 0, 13);\n        x15 ^= rotl((x11 + x07) | 0, 18);\n        x01 ^= rotl((x00 + x03) | 0, 7);\n        x02 ^= rotl((x01 + x00) | 0, 9);\n        x03 ^= rotl((x02 + x01) | 0, 13);\n        x00 ^= rotl((x03 + x02) | 0, 18);\n        x06 ^= rotl((x05 + x04) | 0, 7);\n        x07 ^= rotl((x06 + x05) | 0, 9);\n        x04 ^= rotl((x07 + x06) | 0, 13);\n        x05 ^= rotl((x04 + x07) | 0, 18);\n        x11 ^= rotl((x10 + x09) | 0, 7);\n        x08 ^= rotl((x11 + x10) | 0, 9);\n        x09 ^= rotl((x08 + x11) | 0, 13);\n        x10 ^= rotl((x09 + x08) | 0, 18);\n        x12 ^= rotl((x15 + x14) | 0, 7);\n        x13 ^= rotl((x12 + x15) | 0, 9);\n        x14 ^= rotl((x13 + x12) | 0, 13);\n        x15 ^= rotl((x14 + x13) | 0, 18);\n    }\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nasync function pbkdf2(password, salt, options) {\n    const pwKey = await crypto.subtle.importKey(\"raw\", password, \"PBKDF2\", false, [\"deriveBits\"]);\n    const keyBuffer = await crypto.subtle.deriveBits({\n        name: \"PBKDF2\",\n        hash: \"SHA-256\",\n        salt,\n        iterations: options.c\n    }, pwKey, options.dkLen * 8);\n    return new Uint8Array(keyBuffer);\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i];\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        XorAndSalsa(out, tail, input, ii, out, head);\n        if (i > 0)\n            tail += 16;\n        XorAndSalsa(out, head, input, (ii += 16), out, tail);\n    }\n}\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n", "import { decodeHex, encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { generateRandomString } from \"@oslojs/crypto/random\";\nimport { constantTimeEqual } from \"@oslojs/crypto/subtle\";\nimport { scrypt } from \"./scrypt/index.js\";\nasync function generateScryptKey(data, salt, blockSize = 16) {\n    const encodedData = new TextEncoder().encode(data);\n    const encodedSalt = new TextEncoder().encode(salt);\n    const keyUint8Array = await scrypt(encodedData, encodedSalt, {\n        N: 16384,\n        r: blockSize,\n        p: 1,\n        dkLen: 64\n    });\n    return new Uint8Array(keyUint8Array);\n}\nconst random = {\n    read(bytes) {\n        crypto.getRandomValues(bytes);\n    }\n};\nexport function generateId(length) {\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    return generateRandomString(random, alphabet, length);\n}\nexport function generateIdFromEntropySize(size) {\n    const buffer = crypto.getRandomValues(new Uint8Array(size));\n    return encodeBase32LowerCaseNoPadding(buffer);\n}\nexport class Scrypt {\n    async hash(password) {\n        const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));\n        const key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return `${salt}:${encodeHexLowerCase(key)}`;\n    }\n    async verify(hash, password) {\n        const parts = hash.split(\":\");\n        if (parts.length !== 2)\n            return false;\n        const [salt, key] = parts;\n        const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return constantTimeEqual(targetKey, decodeHex(key));\n    }\n}\nexport class LegacyScrypt {\n    async hash(password) {\n        const salt = encodeHexLowerCase(crypto.getRandomValues(new Uint8Array(16)));\n        const key = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n        return `s2:${salt}:${encodeHexLowerCase(key)}`;\n    }\n    async verify(hash, password) {\n        const parts = hash.split(\":\");\n        if (parts.length === 2) {\n            const [salt, key] = parts;\n            const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt, 8);\n            const result = constantTimeEqual(targetKey, decodeHex(key));\n            return result;\n        }\n        if (parts.length !== 3)\n            return false;\n        const [version, salt, key] = parts;\n        if (version === \"s2\") {\n            const targetKey = await generateScryptKey(password.normalize(\"NFKC\"), salt);\n            return constantTimeEqual(targetKey, decodeHex(key));\n        }\n        return false;\n    }\n}\n", "/**\n * Configure {@link Password} provider given a {@link PasswordConfig}.\n *\n * The `Password` provider supports the following flows, determined\n * by the `flow` parameter:\n *\n * - `\"signUp\"`: Create a new account with a password.\n * - `\"signIn\"`: Sign in with an existing account and password.\n * - `\"reset\"`: Request a password reset.\n * - `\"reset-verification\"`: Verify a password reset code and change password.\n * - `\"email-verification\"`: If email verification is enabled and `code` is\n *    included in params, verify an OTP.\n *\n * ```ts\n * import Password from \"@convex-dev/auth/providers/Password\";\n * import { convexAuth } from \"@convex-dev/auth/server\";\n *\n * export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({\n *   providers: [Password],\n * });\n * ```\n *\n * @module\n */\n\nimport {\n  ConvexCredentials,\n  ConvexCredentialsUserConfig,\n} from \"@convex-dev/auth/providers/ConvexCredentials\";\nimport {\n  EmailConfig,\n  GenericActionCtxWithAuthConfig,\n  GenericDoc,\n  createAccount,\n  invalidateSessions,\n  modifyAccountCredentials,\n  retrieveAccount,\n  signInViaProvider,\n} from \"@convex-dev/auth/server\";\nimport {\n  DocumentByName,\n  GenericDataModel,\n  WithoutSystemFields,\n} from \"convex/server\";\nimport { Value } from \"convex/values\";\nimport { Scrypt } from \"lucia\";\n\n/**\n * The available options to a {@link Password} provider for Convex Auth.\n */\nexport interface PasswordConfig<DataModel extends GenericDataModel> {\n  /**\n   * Uniquely identifies the provider, allowing to use\n   * multiple different {@link Password} providers.\n   */\n  id?: string;\n  /**\n   * Perform checks on provided params and customize the user\n   * information stored after sign up, including email normalization.\n   *\n   * Called for every flow (\"signUp\", \"signIn\", \"reset\",\n   * \"reset-verification\" and \"email-verification\").\n   */\n  profile?: (\n    /**\n     * The values passed to the `signIn` function.\n     */\n    params: Record<string, Value | undefined>,\n    /**\n     * Convex ActionCtx in case you want to read from or write to\n     * the database.\n     */\n    ctx: GenericActionCtxWithAuthConfig<DataModel>,\n  ) => WithoutSystemFields<DocumentByName<DataModel, \"users\">> & {\n    email: string;\n  };\n  /**\n   * Performs custom validation on password provided during sign up or reset.\n   *\n   * Otherwise the default validation is used (password is not empty and\n   * at least 8 characters in length).\n   *\n   * If the provided password is invalid, implementations must throw an Error.\n   *\n   * @param password the password supplied during \"signUp\" or\n   *                 \"reset-verification\" flows.\n   */\n  validatePasswordRequirements?: (password: string) => void;\n  /**\n   * Provide hashing and verification functions if you want to control\n   * how passwords are hashed.\n   */\n  crypto?: ConvexCredentialsUserConfig[\"crypto\"];\n  /**\n   * An Auth.js email provider used to require verification\n   * before password reset.\n   */\n  reset?: EmailConfig | ((...args: any) => EmailConfig);\n  /**\n   * An Auth.js email provider used to require verification\n   * before sign up / sign in.\n   */\n  verify?: EmailConfig | ((...args: any) => EmailConfig);\n}\n\n/**\n * Email and password authentication provider.\n *\n * Passwords are by default hashed using Scrypt from Lucia.\n * You can customize the hashing via the `crypto` option.\n *\n * Email verification is not required unless you pass\n * an email provider to the `verify` option.\n */\nexport function Password<DataModel extends GenericDataModel>(\n  config: PasswordConfig<DataModel> = {},\n) {\n  const provider = config.id ?? \"password\";\n  return ConvexCredentials<DataModel>({\n    id: \"password\",\n    authorize: async (params, ctx) => {\n      const flow = params.flow as string;\n      const passwordToValidate =\n        flow === \"signUp\"\n          ? (params.password as string)\n          : flow === \"reset-verification\"\n            ? (params.newPassword as string)\n            : null;\n      if (passwordToValidate !== null) {\n        if (config.validatePasswordRequirements !== undefined) {\n          config.validatePasswordRequirements(passwordToValidate);\n        } else {\n          validateDefaultPasswordRequirements(passwordToValidate);\n        }\n      }\n      const profile = config.profile?.(params, ctx) ?? defaultProfile(params);\n      const { email } = profile;\n      const secret = params.password as string;\n      let account: GenericDoc<DataModel, \"authAccounts\">;\n      let user: GenericDoc<DataModel, \"users\">;\n      if (flow === \"signUp\") {\n        if (secret === undefined) {\n          throw new Error(\"Missing `password` param for `signUp` flow\");\n        }\n        const created = await createAccount(ctx, {\n          provider,\n          account: { id: email, secret },\n          profile: profile as any,\n          shouldLinkViaEmail: config.verify !== undefined,\n          shouldLinkViaPhone: false,\n        });\n        ({ account, user } = created);\n      } else if (flow === \"signIn\") {\n        if (secret === undefined) {\n          throw new Error(\"Missing `password` param for `signIn` flow\");\n        }\n        const retrieved = await retrieveAccount(ctx, {\n          provider,\n          account: { id: email, secret },\n        });\n        if (retrieved === null) {\n          throw new Error(\"Invalid credentials\");\n        }\n        ({ account, user } = retrieved);\n        // START: Optional, support password reset\n      } else if (flow === \"reset\") {\n        if (!config.reset) {\n          throw new Error(`Password reset is not enabled for ${provider}`);\n        }\n        const { account } = await retrieveAccount(ctx, {\n          provider,\n          account: { id: email },\n        });\n        return await signInViaProvider(ctx, config.reset, {\n          accountId: account._id,\n          params,\n        });\n      } else if (flow === \"reset-verification\") {\n        if (!config.reset) {\n          throw new Error(`Password reset is not enabled for ${provider}`);\n        }\n        if (params.newPassword === undefined) {\n          throw new Error(\n            \"Missing `newPassword` param for `reset-verification` flow\",\n          );\n        }\n        const result = await signInViaProvider(ctx, config.reset, { params });\n        if (result === null) {\n          throw new Error(\"Invalid code\");\n        }\n        const { userId, sessionId } = result;\n        const secret = params.newPassword as string;\n        await modifyAccountCredentials(ctx, {\n          provider,\n          account: { id: email, secret },\n        });\n        await invalidateSessions(ctx, { userId, except: [sessionId] });\n        return { userId, sessionId };\n        // END\n        // START: Optional, email verification during sign in\n      } else if (flow === \"email-verification\") {\n        if (!config.verify) {\n          throw new Error(`Email verification is not enabled for ${provider}`);\n        }\n        const { account } = await retrieveAccount(ctx, {\n          provider,\n          account: { id: email },\n        });\n        return await signInViaProvider(ctx, config.verify, {\n          accountId: account._id,\n          params,\n        });\n        // END\n      } else {\n        throw new Error(\n          \"Missing `flow` param, it must be one of \" +\n            '\"signUp\", \"signIn\", \"reset\", \"reset-verification\" or ' +\n            '\"email-verification\"!',\n        );\n      }\n      // START: Optional, email verification during sign in\n      if (config.verify && !account.emailVerified) {\n        return await signInViaProvider(ctx, config.verify, {\n          accountId: account._id,\n          params,\n        });\n      }\n      // END\n      return { userId: user._id };\n    },\n    crypto: {\n      async hashSecret(password: string) {\n        return await new Scrypt().hash(password);\n      },\n      async verifySecret(password: string, hash: string) {\n        return await new Scrypt().verify(hash, password);\n      },\n    },\n    extraProviders: [config.reset, config.verify],\n    ...config,\n  });\n}\n\nfunction validateDefaultPasswordRequirements(password: string) {\n  if (!password || password.length < 8) {\n    throw new Error(\"Invalid password\");\n  }\n}\n\nfunction defaultProfile(params: Record<string, unknown>) {\n  return {\n    email: params.email as string,\n  };\n}\n"],
  "mappings": "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",
  "names": ["EncodingPadding", "DecodingPadding", "EncodingPadding", "DecodingPadding", "r", "account", "secret"]
}
