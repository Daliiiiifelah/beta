{
  "version": 3,
  "sources": ["../../@convex-dev/auth/src/providers/ConvexCredentials.ts"],
  "sourcesContent": ["/**\n * Configure {@link ConvexCredentials} provider given a {@link ConvexCredentialsUserConfig}.\n *\n * This is for a very custom authentication implementation, often you can\n * use the [`Password`](https://labs.convex.dev/auth/api_reference/providers/Password) provider instead.\n *\n * ```ts\n * import ConvexCredentials from \"@convex-dev/auth/providers/ConvexCredentials\";\n * import { convexAuth } from \"@convex-dev/auth/server\";\n *\n * export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({\n *   providers: [\n *     ConvexCredentials({\n *       authorize: async (credentials, ctx) => {\n *         // Your custom logic here...\n *       },\n *     }),\n *   ],\n * });\n * ```\n *\n * @module\n */\n\nimport {\n  AuthProviderConfig,\n  ConvexCredentialsConfig,\n  GenericActionCtxWithAuthConfig,\n} from \"@convex-dev/auth/server\";\nimport { GenericDataModel } from \"convex/server\";\nimport { GenericId, Value } from \"convex/values\";\n\n/**\n * The available options to a {@link ConvexCredentials} provider for Convex Auth.\n */\nexport interface ConvexCredentialsUserConfig<\n  DataModel extends GenericDataModel = GenericDataModel,\n> {\n  /**\n   * Uniquely identifies the provider, allowing to use\n   * multiple different {@link ConvexCredentials} providers.\n   */\n  id?: string;\n  /**\n   * Gives full control over how you handle the credentials received from the user\n   * via the client-side `signIn` function.\n   *\n   * @returns This method expects a user ID to be returned for a successful login.\n   * A session ID can be also returned and that session will be used.\n   * If an error is thrown or `null` is returned, the sign-in will fail.\n   */\n  authorize: (\n    /**\n     * The available keys are determined by your call to `signIn()` on the client.\n     *\n     * You can add basic validation depending on your use case,\n     * or you can use a popular library like [Zod](https://zod.dev) for validating\n     * the input.\n     */\n    credentials: Partial<Record<string, Value | undefined>>,\n    ctx: GenericActionCtxWithAuthConfig<DataModel>,\n  ) => Promise<{\n    userId: GenericId<\"users\">;\n    sessionId?: GenericId<\"authSessions\">;\n  } | null>;\n  /**\n   * Provide hashing and verification functions if you're\n   * storing account secrets and want to control\n   * how they're hashed.\n   *\n   * These functions will be called during\n   * the `createAccount` and `retrieveAccount` execution when the\n   * `secret` option is used.\n   */\n  crypto?: {\n    /**\n     * Function used to hash the secret.\n     */\n    hashSecret: (secret: string) => Promise<string>;\n    /**\n     * Function used to verify that the secret\n     * matches the stored hash.\n     */\n    verifySecret: (secret: string, hash: string) => Promise<boolean>;\n  };\n  /**\n   * Register extra providers used in the implementation of the credentials\n   * provider. They will only be available to the `signInViaProvider`\n   * function, and not to the `signIn` function exposed to clients.\n   */\n  extraProviders?: (AuthProviderConfig | undefined)[];\n}\n\n/**\n * The Credentials provider allows you to handle signing in with arbitrary credentials,\n * such as a username and password, domain, or two factor authentication or hardware device (e.g. YubiKey U2F / FIDO).\n */\nexport function ConvexCredentials<DataModel extends GenericDataModel>(\n  config: ConvexCredentialsUserConfig<DataModel>,\n): ConvexCredentialsConfig {\n  return {\n    id: \"credentials\",\n    type: \"credentials\",\n    authorize: async () => null,\n    // @ts-expect-error Internal\n    options: config,\n  };\n}\n"],
  "mappings": ";AAiGM,SAAU,kBACd,QAA8C;AAE9C,SAAO;IACL,IAAI;IACJ,MAAM;IACN,WAAW,YAAY;;IAEvB,SAAS;;AAEb;",
  "names": []
}
